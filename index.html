<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Dynamic dependency injection by pwm</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Dynamic dependency injection</h1>
      <h2 class="project-tagline">Sample PHP code that demonstrates injecting a dependency that is not known until runtime.</h2>
      <a href="https://github.com/pwm/dynamic-dependency-injection" class="btn">View on GitHub</a>
      <a href="https://github.com/pwm/dynamic-dependency-injection/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/pwm/dynamic-dependency-injection/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h3>
<a id="intro" class="anchor" href="#intro" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Intro</h3>

<p>In this short article I would like to demonstrate a way to inject dependencies that are not known until runtime. There are many use cases for this and in essence it is about choosing between concrete implementations of some common interface. In object oriented design this is known at the Strategy pattern. The choice itself can be made in various ways, for example via a configuration option or a command line parameter in case of a console command, and I think the dynamic nature of the choice is the most interesting part of the pattern. </p>

<h3>
<a id="a-practical-example" class="anchor" href="#a-practical-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A practical example</h3>

<p>Let's say we have to process 3rd party data feeds periodically. Some of them will return data in JSON format and some in XML. Let's start by defining the interface for reading the feeds:</p>

<div class="highlight highlight-text-html-php"><pre><span class="pl-s1"><span class="pl-k">interface</span> <span class="pl-en">FeedReaderInterface</span></span>
<span class="pl-s1">{</span>
<span class="pl-s1">    <span class="pl-k">public</span> <span class="pl-k">function</span> <span class="pl-en">read</span>(<span class="pl-smi">$url</span>);</span>
<span class="pl-s1">}</span></pre></div>

<p>We have a read() method that requires a $url parameter, which is the url of the remote feed we will read from. Now let's implement (well, simulate) the concrete readers for JSON and XML based feeds:</p>

<div class="highlight highlight-text-html-php"><pre><span class="pl-s1"><span class="pl-k">class</span> <span class="pl-en">JsonFeedReader</span> <span class="pl-k">implements</span> <span class="pl-e">FeedReaderInterface</span></span>
<span class="pl-s1">{</span>
<span class="pl-s1">    <span class="pl-k">public</span> <span class="pl-k">function</span> <span class="pl-en">read</span>(<span class="pl-smi">$url</span>)</span>
<span class="pl-s1">    {</span>
<span class="pl-s1">        <span class="pl-k">return</span> <span class="pl-c1">sprintf</span>(<span class="pl-s"><span class="pl-pds">'</span>reading JSON data from %s ...<span class="pl-pds">'</span></span>, <span class="pl-smi">$url</span>);</span>
<span class="pl-s1">    }</span>
<span class="pl-s1">}</span></pre></div>

<div class="highlight highlight-text-html-php"><pre><span class="pl-s1"><span class="pl-k">class</span> <span class="pl-en">XmlFeedReader</span> <span class="pl-k">implements</span> <span class="pl-e">FeedReaderInterface</span></span>
<span class="pl-s1">{</span>
<span class="pl-s1">    <span class="pl-k">public</span> <span class="pl-k">function</span> <span class="pl-en">read</span>(<span class="pl-smi">$url</span>)</span>
<span class="pl-s1">    {</span>
<span class="pl-s1">        <span class="pl-k">return</span> <span class="pl-c1">sprintf</span>(<span class="pl-s"><span class="pl-pds">'</span>reading XML data from %s ...<span class="pl-pds">'</span></span>, <span class="pl-smi">$url</span>);</span>
<span class="pl-s1">    }</span>
<span class="pl-s1">}</span></pre></div>

<p>Great, now we have our concrete reader strategies. Next, let's create the command itself. For this I will use the Symfony Command component. If you're not familiar with it you can read about it <a href="http://symfony.com/doc/current/components/console/introduction.html">here</a>:</p>

<div class="highlight highlight-text-html-php"><pre><span class="pl-s1"><span class="pl-k">class</span> <span class="pl-en">FeedReaderCommand</span> <span class="pl-k">extends</span> <span class="pl-e">Command</span></span>
<span class="pl-s1">{</span>
<span class="pl-s1">    <span class="pl-k">private</span> <span class="pl-smi">$feedReader</span>;</span>
<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-k">public</span> <span class="pl-k">function</span> <span class="pl-c1">__construct</span>(<span class="pl-c1">FeedReaderInterface</span> <span class="pl-smi">$feedReader</span>)</span>
<span class="pl-s1">    {</span>
<span class="pl-s1">        <span class="pl-k">parent</span><span class="pl-k">::</span>__construct();</span>
<span class="pl-s1">        <span class="pl-smi">$this</span><span class="pl-k">-&gt;</span><span class="pl-smi">feedReader</span> <span class="pl-k">=</span> <span class="pl-smi">$feedReader</span>;</span>
<span class="pl-s1">    }</span>
<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-k">protected</span> <span class="pl-k">function</span> <span class="pl-en">configure</span>()</span>
<span class="pl-s1">    {</span>
<span class="pl-s1">        <span class="pl-smi">$this</span></span>
<span class="pl-s1">            <span class="pl-k">-&gt;</span>setName(<span class="pl-s"><span class="pl-pds">'</span>feed-reader<span class="pl-pds">'</span></span>)</span>
<span class="pl-s1">            <span class="pl-k">-&gt;</span>setDescription(<span class="pl-s"><span class="pl-pds">'</span>This command reads remote feeds. Well, it simulates it anyway.<span class="pl-pds">'</span></span>)</span>
<span class="pl-s1">            <span class="pl-k">-&gt;</span>addArgument(<span class="pl-s"><span class="pl-pds">'</span>feedType<span class="pl-pds">'</span></span>, <span class="pl-c1">InputArgument</span><span class="pl-k">::</span><span class="pl-c1">REQUIRED</span>, <span class="pl-s"><span class="pl-pds">'</span>The type of the feed.<span class="pl-pds">'</span></span>)</span>
<span class="pl-s1">            <span class="pl-k">-&gt;</span>addArgument(<span class="pl-s"><span class="pl-pds">'</span>feedUrl<span class="pl-pds">'</span></span>, <span class="pl-c1">InputArgument</span><span class="pl-k">::</span><span class="pl-c1">REQUIRED</span>, <span class="pl-s"><span class="pl-pds">'</span>The url of the feed.<span class="pl-pds">'</span></span>);</span>
<span class="pl-s1">    }</span>
<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-k">protected</span> <span class="pl-k">function</span> <span class="pl-en">execute</span>(<span class="pl-c1">InputInterface</span> <span class="pl-smi">$input</span>, <span class="pl-c1">OutputInterface</span> <span class="pl-smi">$output</span>)</span>
<span class="pl-s1">    {</span>
<span class="pl-s1">        <span class="pl-smi">$data</span> <span class="pl-k">=</span> <span class="pl-smi">$this</span><span class="pl-k">-&gt;</span><span class="pl-smi">feedReader</span><span class="pl-k">-&gt;</span>read(<span class="pl-smi">$input</span><span class="pl-k">-&gt;</span>getArgument(<span class="pl-s"><span class="pl-pds">'</span>feedUrl<span class="pl-pds">'</span></span>));</span>
<span class="pl-s1">        <span class="pl-smi">$output</span><span class="pl-k">-&gt;</span>writeln(<span class="pl-smi">$data</span>);</span>
<span class="pl-s1">    }</span>
<span class="pl-s1">}</span></pre></div>

<p>Here we have 2 command line arguments, namely "feedType" and "feedUrl". The former is the type of the feed, ie. JSON or XML, the latter is the url. The point is that it is the user who will define these at runtime.</p>

<p>Finally let's create a simple runnable script, namely console.php, that bootstraps this whole thing:</p>

<div class="highlight highlight-text-html-php"><pre><span class="pl-pse">&lt;?php</span><span class="pl-s1"></span>
<span class="pl-s1"><span class="pl-smi">$console</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-c1">Console</span>();</span>
<span class="pl-s1"><span class="pl-smi">$console</span><span class="pl-k">-&gt;</span>add(<span class="pl-k">new</span> <span class="pl-c1">FeedReader\</span><span class="pl-c1">FeedReaderCommand</span>(<span class="pl-k">new</span> <span class="pl-c1">FeedReader\Strategies\</span><span class="pl-c1">JsonFeedReader</span>()));</span>
<span class="pl-s1"><span class="pl-smi">$console</span><span class="pl-k">-&gt;</span>run();</span></pre></div>

<p>Great, it is time to give it a go:</p>

<div class="highlight highlight-source-shell"><pre>[pwm@mbp <span class="pl-k">~</span>]$ app/console feed-reader json <span class="pl-s"><span class="pl-pds">"</span>http://foobar.com/feed<span class="pl-pds">"</span></span>
reading JSON data from http://foobar.com/feed ...</pre></div>

<p>All is well! Hm, except there's a small issue:</p>

<div class="highlight highlight-source-shell"><pre>[pwm@mbp <span class="pl-k">~</span>]$ app/console feed-reader xml <span class="pl-s"><span class="pl-pds">"</span>http://foobar.com/feed<span class="pl-pds">"</span></span>
reading JSON data from http://foobar.com/feed ...
[pwm@mbp <span class="pl-k">~</span>]$ app/console feed-reader foobar <span class="pl-s"><span class="pl-pds">"</span>http://foobar.com/feed<span class="pl-pds">"</span></span>
reading JSON data from http://foobar.com/feed ...</pre></div>

<p>It ignores the "feedType" parameter. Well, not surprising really, given we injected JsonFeedReader, a concrete implementation instead of whatever the user selected. So at the moment we have our strategies, but we don't yet have a way to dynamically choose between them. The problem we face is that we can only access the "feedType" parameter from within the FeedReaderCommand's execute() function hence we cannot use it to choose a reader strategy when instantiating the class. A bit of a catch 22.</p>

<p>Now what if somehow we could capture the computation required to choose a strategy and inject that into FeedReaderCommand? Then, once we possess the value of "feedType" we can execute said computation and the result will be the strategy selected. Sounds a bit cryptic? Well, think closure! Let's edit our console.php script:</p>

<div class="highlight highlight-text-html-php"><pre><span class="pl-s1"><span class="pl-smi">$readerStrategyResolver</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">$feedType</span>) {</span>
<span class="pl-s1">    <span class="pl-smi">$readerStrategies</span> <span class="pl-k">=</span> [</span>
<span class="pl-s1">        <span class="pl-s"><span class="pl-pds">'</span>json<span class="pl-pds">'</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">FeedReader\Strategies\</span><span class="pl-c1">JsonFeedReader</span><span class="pl-k">::</span><span class="pl-c1">class</span>,</span>
<span class="pl-s1">        <span class="pl-s"><span class="pl-pds">'</span>xml<span class="pl-pds">'</span></span>  <span class="pl-k">=&gt;</span> <span class="pl-c1">FeedReader\Strategies\</span><span class="pl-c1">XmlFeedReader</span><span class="pl-k">::</span><span class="pl-c1">class</span>,</span>
<span class="pl-s1">    ];</span>
<span class="pl-s1">    <span class="pl-k">if</span> (<span class="pl-k">!</span> <span class="pl-c1">array_key_exists</span>(<span class="pl-smi">$feedType</span>, <span class="pl-smi">$readerStrategies</span>)) {</span>
<span class="pl-s1">        <span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-c1">\RuntimeException</span>(<span class="pl-s"><span class="pl-pds">'</span>Not a feed type I can read ...<span class="pl-pds">'</span></span>);</span>
<span class="pl-s1">    }</span>
<span class="pl-s1">    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">$readerStrategies</span>[<span class="pl-smi">$feedType</span>]();</span>
<span class="pl-s1">};</span>
<span class="pl-s1"></span>
<span class="pl-s1"><span class="pl-smi">$console</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-c1">Console</span>();</span>
<span class="pl-s1"><span class="pl-smi">$console</span><span class="pl-k">-&gt;</span>add(<span class="pl-k">new</span> <span class="pl-c1">FeedReader\</span><span class="pl-c1">FeedReaderCommand</span>(<span class="pl-smi">$readerStrategyResolver</span>));</span>
<span class="pl-s1"><span class="pl-smi">$console</span><span class="pl-k">-&gt;</span>run();</span></pre></div>

<p>In PHP, just like in many other languages, functions are first-class citizens, which means, amongst other things, that we can pass then around as values. Here we injected the function $readerStrategyResolver, that requires the parameter $feedType and returns a reader strategy based on the value of $feedType. Eagle-eyed readers will also notice that $readerStrategyResolver is a simple factory function.</p>

<p>For this to work we also need to change FeedReaderCommand (I left out configure() for brevity, as that doesn't change):</p>

<div class="highlight highlight-text-html-php"><pre><span class="pl-s1"><span class="pl-k">class</span> <span class="pl-en">FeedReaderCommand</span> <span class="pl-k">extends</span> <span class="pl-e">Command</span></span>
<span class="pl-s1">{</span>
<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-k">private</span> <span class="pl-smi">$readerStrategyResolver</span>;</span>
<span class="pl-s1">    <span class="pl-k">private</span> <span class="pl-smi">$feedReader</span>;</span>
<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-k">public</span> <span class="pl-k">function</span> <span class="pl-c1">__construct</span>(<span class="pl-c1">\</span><span class="pl-c1">Closure</span> <span class="pl-smi">$readerStrategyResolver</span>)</span>
<span class="pl-s1">    {</span>
<span class="pl-s1">        <span class="pl-k">parent</span><span class="pl-k">::</span>__construct();</span>
<span class="pl-s1">        <span class="pl-smi">$this</span><span class="pl-k">-&gt;</span><span class="pl-smi">readerStrategyResolver</span> <span class="pl-k">=</span> <span class="pl-smi">$readerStrategyResolver</span>;</span>
<span class="pl-s1">    }</span>
<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-k">protected</span> <span class="pl-k">function</span> <span class="pl-en">execute</span>(<span class="pl-c1">InputInterface</span> <span class="pl-smi">$input</span>, <span class="pl-c1">OutputInterface</span> <span class="pl-smi">$output</span>)</span>
<span class="pl-s1">    {</span>
<span class="pl-s1">        <span class="pl-smi">$this</span><span class="pl-k">-&gt;</span>setFeedReader(<span class="pl-c1">call_user_func</span>(</span>
<span class="pl-s1">            <span class="pl-smi">$this</span><span class="pl-k">-&gt;</span><span class="pl-smi">readerStrategyResolver</span>,</span>
<span class="pl-s1">            <span class="pl-smi">$input</span><span class="pl-k">-&gt;</span>getArgument(<span class="pl-s"><span class="pl-pds">'</span>feedType<span class="pl-pds">'</span></span>)</span>
<span class="pl-s1">        ));</span>
<span class="pl-s1">        <span class="pl-smi">$data</span> <span class="pl-k">=</span> <span class="pl-smi">$this</span><span class="pl-k">-&gt;</span><span class="pl-smi">feedReader</span><span class="pl-k">-&gt;</span>read(<span class="pl-smi">$input</span><span class="pl-k">-&gt;</span>getArgument(<span class="pl-s"><span class="pl-pds">'</span>feedUrl<span class="pl-pds">'</span></span>))</span>
<span class="pl-s1">        <span class="pl-smi">$output</span><span class="pl-k">-&gt;</span>writeln(<span class="pl-smi">$data</span>);</span>
<span class="pl-s1">    }</span>
<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-k">private</span> <span class="pl-k">function</span> <span class="pl-en">setFeedReader</span>(<span class="pl-c1">FeedReaderInterface</span> <span class="pl-smi">$feedReader</span>)</span>
<span class="pl-s1">    {</span>
<span class="pl-s1">        <span class="pl-smi">$this</span><span class="pl-k">-&gt;</span><span class="pl-smi">feedReader</span> <span class="pl-k">=</span> <span class="pl-smi">$feedReader</span>;</span>
<span class="pl-s1">    }</span>
<span class="pl-s1">}</span></pre></div>

<p>Our new $readerStrategyResolver function is injected upon instantiation and it encapsulates the computation required to choose a concrete reader strategy. Then in execute(), where we have access to the value of "feedType", we can execute $readerStrategyResolver and pass its return value into setFeedReader(). Notice that using a setter also allows us to type hint and thus ensure that our closure returns an implementation of FeedReaderInterface. Neat!</p>

<div class="highlight highlight-source-shell"><pre>[pwm@mbp <span class="pl-k">~</span>]$ app/console feed-reader json <span class="pl-s"><span class="pl-pds">"</span>http://foobar.com/feed<span class="pl-pds">"</span></span>
reading JSON data from http://foobar.com/feed ...
[pwm@mbp <span class="pl-k">~</span>]$ app/console feed-reader xml <span class="pl-s"><span class="pl-pds">"</span>http://foobar.com/feed<span class="pl-pds">"</span></span>
reading XML data from http://foobar.com/feed ...
[pwm@mbp <span class="pl-k">~</span>]$ app/console feed-reader foobar <span class="pl-s"><span class="pl-pds">"</span>http://foobar.com/feed<span class="pl-pds">"</span></span>
  [RuntimeException]
  Not a feed <span class="pl-c1">type</span> I can <span class="pl-c1">read</span> ...</pre></div>

<p>Click <a href="https://github.com/pwm/dynamic-dependency-injection">here</a> for an extended version of this example, which used Pimple, as simple dependency injection container.</p>

<h3>
<a id="conclusion" class="anchor" href="#conclusion" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Conclusion</h3>

<p>We managed to create a simple yet robust way to choose between concrete implementations of a common interface at runtime. The above technique can be used anywhere, where we need to resolve dependencies dynamically, based on user input.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/pwm/dynamic-dependency-injection">Dynamic dependency injection</a> is maintained by <a href="https://github.com/pwm">pwm</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
