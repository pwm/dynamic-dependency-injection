{
  "name": "Dynamic dependency injection",
  "tagline": "Sample PHP code that demonstrates injecting a dependency that is not known until runtime.",
  "body": "In this article I would like to demonstrate a way to inject dependencies that are not known until runtime. There are many use cases for this and in essence it is about choosing between concrete implementations of some common interface. In object oriented design this is known at the Strategy pattern. The choice can be made in various ways, for example via a configuration option or a command line parameter in case of a console command. \r\n\r\nLet's say we have to process some remote feeds periodically. Some feeds will return data in JSON format and some in XML. Let's start by defining the interface:\r\n\r\n```php\r\ninterface FeedReaderInterface\r\n{\r\n    public function read($url);\r\n}\r\n```\r\nWe have a read() method that requires a $url parameter, which is the url of the remote feed we will read from. Now let's implement the concrete readers for JSON and XML based feeds:\r\n\r\n```php\r\nclass JsonFeedReader implements FeedReaderInterface\r\n{\r\n    public function read($url)\r\n    {\r\n        return sprintf('reading JSON data from %s ...', $url);\r\n    }\r\n}\r\n```\r\n\r\n```php\r\nclass XmlFeedReader implements FeedReaderInterface\r\n{\r\n    public function read($url)\r\n    {\r\n        return sprintf('reading XML data from %s ...', $url);\r\n    }\r\n}\r\n```\r\n\r\nGreat, we have our reader strategies. Next, let's create the command itself. I will use the Symfony Command component for this. If you're not familiar with it you can read about it [here](http://symfony.com/doc/current/components/console/introduction.html):\r\n\r\n```php\r\nclass FeedReaderCommand extends Command\r\n{\r\n    private $feedReader;\r\n\r\n    public function __construct(FeedReaderInterface $feedReader)\r\n    {\r\n        parent::__construct();\r\n        $this->feedReader = $feedReader;\r\n    }\r\n\r\n    protected function configure()\r\n    {\r\n        $this\r\n            ->setName('feed-reader')\r\n            ->setDescription('This command reads feeds. Well, it simulates it anyway.')\r\n            ->addArgument('feedType', InputArgument::REQUIRED, 'The type of the feed.')\r\n            ->addArgument('feedUrl', InputArgument::REQUIRED, 'The url of the feed.');\r\n    }\r\n\r\n    protected function execute(InputInterface $input, OutputInterface $output)\r\n    {\r\n        $url = $input->getArgument('feedUrl');\r\n\r\n        $data = $this->feedReader->read($url);\r\n\r\n        $output->writeln($data);\r\n    }\r\n}\r\n```\r\n\r\nHere we defined 2 CLI arguments, namely \"feedType\" and \"feedUrl\", that the user will define at runtime. The former is the type of the feed, ie. JSON or XML, the latter is the url. \r\n\r\nFinally let's create the runnable \"console.php\" script that bootstraps this whole thing:\r\n\r\n```php\r\n$console = new Console();\r\n$console->add(new FeedReader\\FeedReaderCommand(new FeedReader\\Strategies\\JsonFeedReader()));\r\n$console->run();\r\n```\r\n\r\nGreat, it is time to test it:\r\n\r\n```bash\r\n[pwm@mbp ~]$ app/console feed-reader json \"http://foobar.com/feed\"\r\nreading JSON data from http://foobar.com/feed ...\r\n```\r\n\r\nIt works! All is well! Hm, except there's a small issue:\r\n\r\n```bash\r\n[pwm@mbp ~]$ app/console feed-reader xml \"http://foobar.com/feed\"\r\nreading JSON data from http://foobar.com/feed ...\r\n[pwm@mbp ~]$ app/console feed-reader foobar \"http://foobar.com/feed\"\r\nreading JSON data from http://foobar.com/feed ...\r\n```\r\n\r\nIt ignores the feed type. Well, not surprising given we injected JsonFeedReader, a concrete implementation, in console.php. So we have our strategies, but we don't yet have a way to dynamically choose between them. The problem we face is that we have no access to the feed type parameter when we instantiate FeedReaderCommand.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}