{
  "name": "Dynamic dependency injection",
  "tagline": "Sample PHP code that demonstrates injecting a dependency that is not known until runtime.",
  "body": "### Intro\r\n\r\nIn this short article I would like to demonstrate a way to inject dependencies that are not known until runtime. There are many use cases for this and in essence it is about choosing between concrete implementations of some common interface. In object oriented design this is known at the Strategy pattern. The choice itself can be made in various ways, for example via a configuration option or a command line parameter in case of a console command, and I think it is the most interesting part of the pattern. \r\n\r\n### A practical example\r\n\r\nLet's say we have to process some remote feeds periodically. Some feeds will return data in JSON format and some in XML. Let's start by defining the interface:\r\n\r\n```php\r\ninterface FeedReaderInterface\r\n{\r\n    public function read($url);\r\n}\r\n```\r\nWe have a read() method that requires a $url parameter, which is the url of the remote feed we will read from. Now let's implement (well, simulate) the concrete readers for JSON and XML based feeds:\r\n\r\n```php\r\nclass JsonFeedReader implements FeedReaderInterface\r\n{\r\n    public function read($url)\r\n    {\r\n        return sprintf('reading JSON data from %s ...', $url);\r\n    }\r\n}\r\n```\r\n\r\n```php\r\nclass XmlFeedReader implements FeedReaderInterface\r\n{\r\n    public function read($url)\r\n    {\r\n        return sprintf('reading XML data from %s ...', $url);\r\n    }\r\n}\r\n```\r\n\r\nGreat, we have our concrete reader strategies. Next, let's create the command itself. I will use the Symfony Command component for this. If you're not familiar with it you can read about it [here](http://symfony.com/doc/current/components/console/introduction.html):\r\n\r\n```php\r\nclass FeedReaderCommand extends Command\r\n{\r\n    private $feedReader;\r\n\r\n    public function __construct(FeedReaderInterface $feedReader)\r\n    {\r\n        parent::__construct();\r\n        $this->feedReader = $feedReader;\r\n    }\r\n\r\n    protected function configure()\r\n    {\r\n        $this\r\n            ->setName('feed-reader')\r\n            ->setDescription('This command reads remote feeds. Well, it simulates it anyway.')\r\n            ->addArgument('feedType', InputArgument::REQUIRED, 'The type of the feed.')\r\n            ->addArgument('feedUrl', InputArgument::REQUIRED, 'The url of the feed.');\r\n    }\r\n\r\n    protected function execute(InputInterface $input, OutputInterface $output)\r\n    {\r\n        $data = $this->feedReader->read($input->getArgument('feedUrl'));\r\n        $output->writeln($data);\r\n    }\r\n}\r\n```\r\n\r\nWe have 2 command line arguments, namely \"feedType\" and \"feedUrl\". The point is that it is the user who define these at runtime. The former is the type of the feed, ie. JSON or XML, the latter is the url.\r\n\r\nFinally let's create a simple runnable script, console.php, that bootstraps this whole thing:\r\n\r\n```php\r\n<?php\r\n$console = new Console();\r\n$console->add(new FeedReader\\FeedReaderCommand(new FeedReader\\Strategies\\JsonFeedReader()));\r\n$console->run();\r\n```\r\n\r\nGreat, it is time to test it:\r\n\r\n```bash\r\n[pwm@mbp ~]$ app/console feed-reader json \"http://foobar.com/feed\"\r\nreading JSON data from http://foobar.com/feed ...\r\n```\r\n\r\nIt works! All is well! Hm, except there's a small issue:\r\n\r\n```bash\r\n[pwm@mbp ~]$ app/console feed-reader xml \"http://foobar.com/feed\"\r\nreading JSON data from http://foobar.com/feed ...\r\n[pwm@mbp ~]$ app/console feed-reader foobar \"http://foobar.com/feed\"\r\nreading JSON data from http://foobar.com/feed ...\r\n```\r\n\r\nIt ignores the \"feedType\" parameter. Well, not surprising really given we injected JsonFeedReader, a concrete implementation instead of whatever the user selected. So at the moment we have our strategies, but we don't yet have a way to dynamically choose between them. The problem we face is that we can only access the \"feedType\" parameter from within the FeedReaderCommand's execute() function hence we cannot use it to choose a reader strategy when instantiating the FeedReaderCommand. A bit of a catch 22.\r\n\r\nNow what if somehow we could capture the computation required to choose a strategy and inject that into FeedReaderCommand? Then, once we possess the value of \"feedType\" we can execute said computation and the result will be the strategy selected. Sounds a bit cryptic? Well, think closure! Let's edit our console.php script:\r\n\r\n```php\r\n$readerStrategyResolver = function ($feedType) {\r\n    $readerStrategies = [\r\n        'json' => FeedReader\\Strategies\\JsonFeedReader::class,\r\n        'xml'  => FeedReader\\Strategies\\XmlFeedReader::class,\r\n    ];\r\n    if (! array_key_exists($feedType, $readerStrategies)) {\r\n        throw new \\RuntimeException('Not a feed type I can read ...');\r\n    }\r\n    return new $readerStrategies[$feedType]();\r\n};\r\n\r\n$console = new Console();\r\n$console->add(new FeedReader\\FeedReaderCommand($readerStrategyResolver));\r\n$console->run();\r\n```\r\n\r\nIn PHP, just like in many other languages, functions are first-class citizens, which means, amongst other things, that we can pass then around as values. Here we injected the function $readerStrategyResolver, that requires the parameter $feedType and returns a reader strategy based on the value of $feedType. Eagle-eyed readers will also notice that $readerStrategyResolver is a simple factory function.\r\n\r\nFor this to work we also need to change FeedReaderCommand (I left out configure() for brevity, as that doesn't change):\r\n\r\n```php\r\nclass FeedReaderCommand extends Command\r\n{\r\n\r\n    private $readerStrategyResolver;\r\n    private $feedReader;\r\n\r\n    public function __construct(\\Closure $readerStrategyResolver)\r\n    {\r\n        parent::__construct();\r\n        $this->readerStrategyResolver = $readerStrategyResolver;\r\n    }\r\n\r\n    protected function execute(InputInterface $input, OutputInterface $output)\r\n    {\r\n        $this->setFeedReader(call_user_func(\r\n            $this->readerStrategyResolver,\r\n            $input->getArgument('feedType')\r\n        ));\r\n\r\n        $output->writeln($this->feedReader->read($input->getArgument('feedUrl')));\r\n    }\r\n\r\n    private function setFeedReader(FeedReaderInterface $feedReader)\r\n    {\r\n        $this->feedReader = $feedReader;\r\n    }\r\n}\r\n```\r\n\r\nOur new $readerStrategyResolver function is injected upon instantiation and it encapsulates the computation required to choose a concrete reader strategy. Then in execute(), where we have access to \"feedType\", we can execute $readerStrategyResolver and pass its return value into setFeedReader(). Notice that using a setter allows us to type hint and thus ensure that our closure returns an implementation of FeedReaderInterface. Voila!\r\n\r\n```bash\r\n[pwm@mbp ~]$ app/console feed-reader json \"http://foobar.com/feed\"\r\nreading JSON data from http://foobar.com/feed ...\r\n[pwm@mbp ~]$ app/console feed-reader xml \"http://foobar.com/feed\"\r\nreading XML data from http://foobar.com/feed ...\r\n[pwm@mbp ~]$ app/console feed-reader foobar \"http://foobar.com/feed\"\r\n  [RuntimeException]\r\n  Not a feed type I can read ...\r\n```\r\n\r\n### Conclusion\r\n\r\nWe managed to create a simple yet robust way to choose between concrete implementations of a common interface at runtime. The above technique can be used anywhere, where we need to resolve dependencies dynamically, based on user input.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}